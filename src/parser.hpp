#ifndef _PARSER_H_
#define _PARSER_H_

#include <cstdint>
#include <exception>
#include <string>
#include <istream>
#include <deque>
#include <vector>
#include <iostream>
#include <algorithm>
#include <functional>
#include <map>
#include <stack>
#include <set>
#include <boost/regex.hpp>

#include "id/id.hpp"
#include "id/pid.hpp"
#include "util/util.hpp"
#include "outp/lnstruct.hpp"
#include "syntax/routines.hpp"
#include "ex.hpp"

namespace dvl
{
	////////////////////////////////////////////////////////////////////////////////////
	// routine interface
	//

	/**
	 * Interface of the parser that gets provided to the routines.
	 * This class provides features required to mark a routine for
	 * repetition, handle exceptions thrown by children,
	 * thus providing means to  emulate exception-handling in a recursion-like maner
	 * and register child- and next routines for execution.
	 *
	 * If a routine terminates with an error-state, the input-stream will be reset to the point
	 * before the routine was run.
	 */
	class routine_interface
	{
	public:
		virtual ~routine_interface(){}

		/**
		 * Sets the repeat-flag for a given parser-routine.
		 *
		 * Multiple calls to this interface won't have any another effect
		 * than a single call.
		 */
		virtual void repeat() = 0;

		/**
		 * Runs the specified routine as following up on the current routine. Note that
		 * child-routines will always be run first. Multiple calls to this method in the same
		 * run will have the effect of overriding each other. Only the last call during a run
		 * will have effect on the execution.
		 *
		 * Note that this method only accepts "standard"-routines, NOT parser_routines.
		 *
		 * @param r the routine that should run after this routine completed
		 */
		virtual void run_as_next(routine* r) = 0;

		/**
		 * Runs the specified routine as child of this routine. Multiple calls to this
		 * method within the same run of a routine will have the effect of overriding each
		 * other. Only the last call will have any effect.
		 *
		 * Note that this method only accepts "standard"-routines, NOT parser_routines.
		 *
		 * @param r the routine to run
		 */
		virtual void run_as_child(routine* r) = 0;

		/**
		 * Exits without any side-effects, if the child-routine didn't throw any exception,
		 * otherwise the exception will be rethrown by the method. Needs to be called by any
		 * routine using this interface and owning child-routines!
		 *
		 * If no child-routine was run, this will be considered as faultfree status and
		 * the function will terminate without error
		 *
		 * @throws parser_exception if any child-routine threw an exception
		 * @see parser_exception
		 */
		virtual void check_child_exception() throw(parser_exception) = 0;

		/**
		 * returns the input-stream associated with this parser
		 */
		virtual std::wistream& get_istream() = 0;

		/**
		 * Used to display a stacktrace for the specified stack_trace_routine
		 *
		 * @param r the routine for which the stacktrace will be displayed.
		 */
		virtual void visit(stack_trace_routine& r) = 0;
	};

	////////////////////////////////////////////////////////////////////////////////////
	// parser_routine_factory
	//

	/**
	 * builds a wrapper for a specific routine that adds functionality required
	 * by the parser.
	 *
	 * @see pid
	 * @see routine
	 * @see routine_interface
	 */
	class parser_routine_factory
	{
	public:
		/**
		 * Implementation of routines that interface with parsers. These routines
		 * are single-use and will be deleted once the entity represented by such a
		 * routine is complete, or the routine terminated with an error. This means that
		 * this any routine inheriting from this class must not be run more often
		 * than once and should throw an exception if run is called multiple times without
		 * the repeat-flag set. This is ensured by the implementation of parser_routine
		 * itself. Instances of this class will be produced by the parser_routine_factory.
		 *
		 * @see routine_interface
		 * @see routine
		 * @see parser_routine::legal_run
		 */
		class parser_routine : public routine
		{
		private:
			/**
			 * Flag to determine whether a repeated run of this routine is legal.
			 * Set to true on initialization
			 *
			 * @see repeat
			 * @see ri_run
			 */
			bool legal_run;

			/**
			 * Flag to determine whether an insertion is legal. There may be exactly one child
			 * placed per run. This flag is used to prevent further placements.
			 *
			 * @see place_child
			 * @see ri_run
			 */
			bool legal_insert;
		public:
			parser_routine(pid id): routine(id), legal_run(true), legal_insert(false){}

			virtual ~parser_routine(){}

			/**
			 * returns the lnstruct generated by this routine. By contract
			 * multiple calls on the same instance must always return the same pointer.
			 *
			 * This function must return a valid value after the first call to run. In
			 * contrast before the first call to run a nullptr may be returned as well.
			 * This method may not throw an exception. Since the lnstruct produced by this
			 * class is owned by the parser processing the routine, this method must return
			 * the lnstruct generated by the routine once it is allocated.
			 *
			 * @return the lnstruct produced by this routine
			 * @see lnstruct
			 */
			virtual lnstruct* get_result() = 0;

		protected:
			/**
			 * Callback to place the lnstruct produced by the child in the
			 * parents lnstruct. Note that this function will only be called
			 * if the previous child-routine didn't fail.
			 *
			 * This method may throw an exception in case of an invalid insertion.
			 * E.g. if the routine itself wasn't run yet, or the input is invalid.
			 * By contract this method must throw an exception if the routine wasn't run
			 * so far.
			 *
			 * @param l the lnstruct to insert
			 * @throws parser_exception if the lnstruct cant be placed
			 * @see parser_exception::lnstruct_premature_insertion
			 */
			virtual void place_child(lnstruct* l) throw(parser_exception) = 0;

			/**
			 * Runs the current routine on the given parser_interface
			 *
			 * @throws parser_exception if the rule defined by the routine is violated
			 * @see ri_run
			 */
			virtual void run(routine_interface &ri) throw(parser_exception) = 0;

		public:
			/**
			 * Called by the routine_interface to run this routine. This method
			 * will check the legal_run method to assert the routine won't be used
			 * repeadately and throws a parser_exception if this constraint is violated.
			 *
			 * @param ri the routine_interface on which this routine runs
			 * @see repeat
			 * @see legal_run
			 * @see run
			 */
			void ri_run(routine_interface &ri)
				throw(parser_exception)
			{
				if(!legal_run)
					throw parser_exception(get_pid(), parser_exception::routine_invalid_repeat());

				legal_run = false;
				legal_insert = true;

				run(ri);
			}

			/**
			 * Called by the routine-interface to place a child-element. Prevents
			 * repetitive/invalid calls of place_child. I.e. at most one child-element
			 * may be placed in this routine per call to run. It is not allowed to insert
			 * a nullptr as child, as this would possibly break the output-tree apart.
			 *
			 * @see place_child
			 * @see legal_insert
			 */
			void ri_place_child(lnstruct *l)
				throw(parser_exception)
			{
				if(!legal_insert)
					throw parser_exception(get_pid(), parser_exception::lnstruct_invalid_insertion("routine"));

				if(l == nullptr)
					throw dvl::parser_exception(get_pid(), dvl::parser_exception::nullptr_error("Child may not be null"));

				legal_insert = false;

				place_child(l);
			}

		protected:
			/**
			 * Called by inheriting routines to set the repeat-flag for this routine.
			 * A call to this method will mark the routine for repetition and mark
			 * the routine as legal for repetition.
			 *
			 * @param ri the routine_interface on which this routine will be marked for repetition
			 * @see ri_run
			 * @see legal_run
			 */
			void repeat(routine_interface &ri)
			{
				ri.repeat();

				legal_run = true;
			}

			/**
			 * Returns true if the current run is valid. I.e. if it is either the first run, or
			 * the last run called repeat.
			 *
			 * @return true if the run is valid
			 * @see legal_run
			 * @see repeat
			 */
			bool valid_run()
			{
				return legal_run;
			}
		};

		/**
		 * Typedef for a function to transform a standard-routine into a
		 * parser_routine
		 *
		 * @see routine
		 * @see parser_routine
		 */
		typedef std::function<parser_routine*(routine*)> transform;

		parser_routine_factory();
		virtual ~parser_routine_factory(){}

		/**
		 * Translates a routine into a parser_routine
		 * based on the type provided with the pid of the
		 * routine given as parameter
		 *
		 * @see pid
		 * @see routine
		 * @see parser_routine
		 */
		parser_routine* build_routine(routine* r) throw(parser_exception);

		/**
		 * Registers a transformation-routine to generate
		 * a parser_routine from a given routine
		 */
		void register_transformation(uint8_t type, transform t);

		/**
		 * Registers the standard-routines with the specified factory
		 *
		 * This includes: @link fork_routine, @link empty_routine
		 * @link loop_routine, @link struct_routine, @link string_matcher_routine,
		 * @link empty_routine, @link echo_routine, @link stack_trace_routine
		 *
		 * @param f the factory to configure with the specified routines
		 */
		static void default_config(parser_routine_factory &f);
	private:
		/**
		 * Maps types onto the respective transformation-function
		 *
		 * @see pid
		 * @see transform
		 */
		std::map<uint8_t, transform> transformations;
	};

	//////////////////////////////////////////////////////////////////////////////////
	// parser context
	//

	/**
	 * A context-structure holding all relevant objects required to run
	 * the parser.
	 *
	 * @see parser
	 */
	struct parser_context
	{
	public:
		// TODO using wistringstream is a temporary fix to allow regex_routine to function
		// and should be replaced by an appropriate input-stream that allows for bidirectional
		// iterators as soon as available

		parser_context(std::wistringstream &str, routine_tree_builder &builder, pid_table &pt,
				parser_routine_factory &factory):
			str(str), builder(builder), pt(pt), factory(factory)
		{}

		/**
		 * The input-stream associated with this context
		 */
		std::wistringstream &str;

		/**
		 * The routine_tree_builder that was used to generate the syntax-tree
		 *
		 * @see routine_tree_builder
		 */
		routine_tree_builder &builder;

		/**
		 * Lookup table for names of pids that will be used within this context
		 *
		 * @see pid_table
		 */
		pid_table &pt;

		/**
		 * Factory for building routines within this context. This can
		 * be used to introduce new types of routines.
		 *
		 * @see parser_routine_factory
		 */
		parser_routine_factory &factory;
	};

	/////////////////////////////////////////////////////////////////////////////////
	// parser
	//

	// TODO dot-graph in documentation

	/**
	 * Implements the basic parser that processes the input in accordance with it's provided input.
	 *
	 * This class owns any output it produces until it terminates successfully. This means upon
	 * successful termination the ownership of the output will be transfered to the calling
	 * method. Otherwise the output will automatically be deallocated by the parser upon
	 * destruction.
	 *
	 * @see parser_context
	 * @see routine_interface
	 */
	class parser : public routine_interface
	{
	private:
		typedef parser_routine_factory::parser_routine proutine;

		/**
		 * Defines a single stack-frame in the execution-stack of this
		 * parser.
		 *
		 * @see s
		 */
		class stack_frame
		{
			friend class parser;

			/**
			 * Constructs a stack-frame with a fixed offset for the input-stream
			 * in order to reset the stream. This marker will be kept for the
			 * entire life-time of the struct
			 *
			 * @see stream_marker
			 */
			stack_frame(int pos): stream_marker(pos){}

			/**
			 * The routine currently running in this stack-frame
			 */
			proutine *cur = nullptr;

			/**
			 * The routine that is supposed to run after cur
			 *
			 * @see cur
			 */
			proutine *next = nullptr;

			/**
			 * True if the current routine should be repeated when this stack-frame
			 * is in execution the next time
			 */
			bool repeat = false;

			/**
			 * Indicates whether the current routine is run for the first time.
			 * False if the routine ran for the first time, otherwise it is true
			 *
			 * @see repeat
			 */
			bool repeated = false;

			/**
			 * Marker for the front-most  output-struct of the level associated with this
			 * stackframe
			 *
			 * @see next_insert
			 */
			lnstruct *result = nullptr;

			/**
			 * Pointer to the next insertion-position. Initially this points
			 * to @link result, for any further routines it should point to
			 * the next empty slot.
			 *
			 * This pointer can be used for consecutive routines in the same frame.
			 * This means that in the initial state the pointer points to
			 * @code cur->get_result()->get_next()
			 *
			 * @see lnstruct::get_next()
			 * @see result
			 */
			lnstruct **next_insert = &result;	// start insertion at first position (= result of this frame)

			/**
			 * Marker to recover the stream-position on which the input-stream
			 * was when this frame started execution
			 */
			const long stream_marker;

			/**
			 * Switches to the next routine and deallocates the currently active one.
			 */
			void switch_to_next_routine()
			{
				delete cur;
				cur = next;
				next = nullptr;
				repeat = false;
				repeated = false;
			}
		public:
			/**
			 * Copies a stack-frame. This is required to make sure that
			 * @link next_insert will point to the correct result-pointer
			 * (of the new instance) instead of to the old structure.
			 * All other fields will be copied in a shallow manner.
			 *
			 * @see next_insert
			 */
			stack_frame(const stack_frame &frame);
		};

		/**
		 * Routine required to store the root of the output-tree
		 * after the routine-execution terminates.
		 *
		 * This class will place the root of the parser-graph into the execution-queue
		 * and place the result in the output-variable of the graph.
		 *
		 * @see parser::result
		 * @see context::builder
		 */
		class output_helper : public proutine
		{
		private:
			/**
			 * Reference to the pointer of the output (required to place output in the
			 * correct location)
			 */
			lnstruct *&ln;

			/**
			 * The root of the parser-tree. Will be used to kick off the parsing-process
			 *
			 * @see parser_context::builder::getdd
			 */
			routine *root;
		public:
			/**
			 * Constructs a new output_helper for the specified output-location
			 * and routine-graph-root
			 *
			 * @param ln reference to the storage-location of the output
			 * @param root the root of the routine-graph
			 */
			output_helper(lnstruct *& ln, routine *root):
				proutine(ROOT),
				ln(ln),
				root(root){}

			/**
			 * Contradicts the definition of @link parser_routine_factory::routine::get_result()
			 * Do not copy this special behavior, as this routine is a special case
			 * only used for this specific purpose.
			 *
			 * @return a nullpointer
			 */
			lnstruct *get_result(){ return nullptr; }	// shouldn't be called

			/**
			 * Emplaces the result of the child-routine.
			 *
			 * In this case the output will be used to store the output.
			 */
			void place_child(lnstruct *ln) throw(parser_exception) { this->ln = ln; }

			/**
			 * Registers the root of the parser-graph in the parser
			 *
			 * No check for exceptions!
			 *
			 * @param ri the routine_interface on which this routine runs
			 */
			void run(routine_interface &ri) throw(parser_exception)	{ ri.run_as_child(root); }

		};

		/**
		 * Structure to store all updates made to the parser
		 * by the currently routine.
		 */
		struct
		{
			friend class parser;

			/**
			 * This routine will be placed for execution as next routine
			 * after this routine
			 */
			routine *next = nullptr;

			/**
			 * The routine to execute as child of this routine
			 */
			routine *child = nullptr;

			/**
			 * If set to true, the current routine will be repeated.
			 */
			bool repeat = false;

			/**
			 * Resets the struct to it's initial state
			 *
			 * @see next
			 * @see child
			 * @see repeat
			 */
			void reset()
			{
				next = nullptr;
				child = nullptr;
				repeat = false;
			}
		} update;

		/**
		 * The stack-frame associated with this parser
		 *
		 * @see stack_frame
		 */
		std::stack<stack_frame> s;

		/**
		 * Keeps a copy of the latest exception that was thrown in this
		 * parser in order to keep child-routines stable.
		 *
		 * @see check_child_exception()
		 */
		parser_exception *e = nullptr;

		/**
		 * The context used to configure this parser
		 *
		 * @see parser_context
		 */
		parser_context &context;

		/**
		 * The output from the parser will be stored here upon termination
		 * of the graph.
		 *
		 * @see output_helper
		 * @see get_output()
		 */
		lnstruct *result = nullptr;

		/**
		 * Unwinds the stack until the next routine to run is found.
		 * The top-most stack will be popped off irrespectively of other
		 * constraints
		 *
		 * @throw parser_exception if the unwinwding fails
		 *
		 * @see s
		 * @see unwind_ex()
		 */
		void unwind() throw(parser_exception);

		/**
		 * Undinws the stack until the next routine that can handle the failure
		 * is found
		 *
		 * @throw parser_exception if the unwinding fails
		 *
		 * @see s
		 * @see unwind()
		 */
		void unwind_ex() throw(parser_exception);

		/**
		 * Asserts that the stack contains at least the root of the parser-graph
		 */
		inline void assert_stack_not_empty()
			throw(parser_exception)
		{
			if(s.size() < 2)
				throw parser_exception(PARSER, "Invalid operation - stack is empty");
		}
	public:
		/**
		 * Builds a new parser from the specified parser_context.
		 *
		 * @param context the parser_context defining this parsers behavior
		 * @see parser_context
		 */
		parser(parser_context &context) throw(parser_exception);

		/**
		 * Destroys this parser-instance. If the parser didn't terminate
		 * successful, the parser will yield a nullptr as output and
		 * destroy any output that was created so far, otherwise the
		 * ownership of the parsers output will be transferred to the calling
		 * routine upon successful terminate of @link run
		 *
		 * @see run
		 * @see result
		 */
		~parser();

		/**
		 * Starts this parser. Throws an exception if the language provided to the parser
		 * doesn't contain the input or if the parser fails internally (e.g. state-inconsistencies)
		 *
		 * @throw parser_exception if the parser fails
		 */
		void run() throw(parser_exception);

		/**
		 * Returns the output of this parser. If the parser fails a nullpointer will
		 * be returned. If the parser succeeds the using routine must get the output
		 * via this method and deallocate it
		 *
		 * @return the output of this parser
		 */
		lnstruct *get_result(){ return result; }

		// routine_interface

		/**
		 * Marks the current routine for repetition
		 *
		 * @see routine_interface::repeat
		 * @see update
		 */
		void repeat(){ update.repeat = true; }

		/**
		 * Sets the routine to run as next after the current routine
		 *
		 * @param r the routine to run as next on the currently active frame
		 *
		 * @see routine_interface::run_as_next(routine*)
		 * @see update
		 */
		void run_as_next(routine *r){ update.next = r; }

		/**
		 * Sets the routine to run as child of the currently active routine
		 *
		 * @param r the routine to run as child of the currently active frame
		 *
		 * @see routine_interface::run_as_child(routine*)
		 * @see update
		 */
		void run_as_child(routine *r){ update.child = r; }

		/**
		 * Checks if the exception-flag is set. If any child-routine of
		 * the currently active routine (a routine running on a higher
		 * stack_frame) threw an exception and it wasn't handled before, it
		 * will be rethrown by this method.
		 *
		 * @throws parser_exception if the exception-flag is set
		 *
		 * @see routine_interface::check_child_exception()
		 */
		void check_child_exception()
			throw(parser_exception)
		{
			if(e != nullptr)
				throw *e;
		}

		/**
		 * Getter for the input-stream this parser uses.
		 *
		 * @return the wistream used by this parser
		 *
		 * @see routine_interface::get_istream()
		 */
		std::wistream& get_istream(){ return context.str; }

		/**
		 * Visitor for a stack_trace routines. Will display the currently
		 * active stack-trace
		 *
		 * @param r the stack_trace_routine to display the stack for
		 *
		 * @see routine_interface::visit(stack_trace_routine&)
		 */
		void visit(stack_trace_routine &r);
	};
}

#endif
